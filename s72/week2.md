BOX MODEL * ABSOLUTE POSTION

text position은 다음

[박스모델]
마진 > 보더 > 패딩 > 컨텐츠

CSS 레이아웃이라는 박스 안에 들어가는 모든 앨리먼트들에 대한 규격. 모든 앨리먼트는 위와 같은 박스모델을 가지고 있다.

마진은 무조건 투명하다. 현재는 마진에 색을 칠할 수 없고 css4때 규정될 가능성이 있음.


보더는 외곽선을 치는 경계면. 외곽선은 아니고, 사실 끝 없는 크기를 가질 수 있는 영역이다. width 역시 컨텐츠처럼 사용할 수 있음.

보더에 백그라운드를 줄 수도 있음. 현재 드래프트상태이긴하지만.


패딩도 현재는 투명. 보더로부터 컨텐츠박스를 띄워주기 위한 역할.



컨텐츠 영역! 우리가 일반적인 내용들을 이곳에 배치한다.




[박스사이징?]
width와 height를 계산할 때, 어디를 기준으로 할지를 의미.
(레이아웃을 확립한놈들은 MS - MS는 보더박스 기준으로 width를 계산했으나, css 2.1 표준으로 지정된 것은 컨텐츠박스가 되어버렸음.)

css2.1 이후에 박스 사이징을 확장할 수 있도록 변경되었음. IE5.5때 사실 있던 규격인데, 이제사 넣고있음.

보더박스 / 패딩박스/ 컨텐츠박스를 사용할 수 있고, 현재의 기본값은 컨텐츠박스를 기준으로 사이즈가 잡힘.


패딩박스는 파이어폭스만 구현.



[고전 박스모델]
BOX-SHADOW는 그림자를 주기위해 만들었음. offset을 기준으로 그림자를 그림. 그림자 크기는 box크기와 같음
blur를 빼면 sprite만큼 떨어진 보더 바깥쪽에 그려지는 외곽선을 얻을 수 있음. (외곽선 밖의 외곽선)

마진>아웃라인>박스쉐도우>보더박스>박스쉐도우인셋>패딩박스>컨텐츠박스

박스 쉐도우는 무한히 만들 수 있다. 갯수에 제한이 없음
보더의 래디우스를 따라온다. 동심원을 그리는 것을 박스 쉐도우를 통해 구현할 수 있다.



컨텐츠박스에만 자식을 배치할 수 있고, 다른곳은 현재 그렇지 않다.
자식을 배치할 수 있는 공간이 커텐츠 박스. 자식이 쓸 수 있는 공간이 그렇다면 컨텐츠박스를 써야하는데,

보더값을 %로 주면, 보더를 우선 %로 배분한 뒤, 나머지를 컨텐츠가 먹게된다.


컨텐츠박스는 컨텐츠가 먼저 확보되고 나머지를 정의하는데, 보더박스는 전체를 정의하고 컨텐츠가.


[비율!!]
모든 %는 부모로부터의 비율.
tranform은 자기 자신을 기준.
tranform 제외하고 나머지는 부모로부터 %를 계산한다.


어느쪽을 px로 확정짓고
어디를 %로 사용할 것인가를 고려해야한다.


인라인 앨리먼트는 테긋트를 전부 


플로트, 보더, 박스사이즈에 대한 굉장한 오해.

<백그라운드>
백그라운드는 보더박스 전체를 다 칠한다.


노멀플로우 내에서 박스쉐도우 뒤에나온게 이긴다!
이걸 이길려면.. relative position을 주게 되면, rp가 그 위에 덮어씌운다.

노멀플로우대로 박스사이징을 정렬한 뒤, 포지션이 나오면 먼저 나온게 아김..-_-ㄷ

RP로 이길 수 있다! relative position

마우스 온오버를 하면 이겨야지! 그때 포지션 렐러티브를 줬다가 빼는거.




style태그 하나에는 sheet라는 객체 하나가 들어있다.
시트 개별적으로 룰을 가지고 있다.
이 룰을 포함한 것이 룰셋.

시트 > 룰셋 > 룰

룰 타입은 7가지 표준이 있음.

지시자를 가지고 있는 앨리먼트가 따로 있음
@mediaquery, @important, @keyframes ....
css4 규격에서 지정되어있는 변수명들 디렉티브들 전부 다 골뱅이로 표현.

@fontface 이런 것들 모두 디렉티브 규격
원래는 css에 없는거지만, 이제부터 특별한 css 속성을 가리키도록 하는 것을 의미한다.

아래 anibs는 from과 to라는 속성을 가지고 있음. box-shadow는 애니메이션을 가질 수 있음.
@keyframes anibs{
    from{...}
    to{....}
}

css 내에서는
animation:anibs 0.4s linear alternate infinite;
위와 같이 표현한다.

anibs라는 keyframes 디렉티브로 지정한 속성을 사용할 수 있다.




셀렉터는 각각의 디렉티브 내에서 다르게 작동한다.
셀렉터는 특정 디렉티브 내에서 무엇을 지정하는지! 디렉티브별로 셀렉터는 모두 다르게 나올 것이다.


css 표준은 0px 안됨. 0 px를 쓰면안됨



박스 쉐도우는 지오매트리에 관여하지 않는다.

박스쉐도우를 늘였다 줄이는건 돔을 재계산하거나 하는거 없음.

fragment..
박스 쉐도우를 몇 겹을 쳐도 크게 느려지지 않는다.

그림을 칠하는 쪽 스펙들은, 대부분 지오매트리를 건들지 않고(no reflow) GPU를 사용하려고 한다.


POSITION ABSOLUTE


fixed는 PC브라우저에선 별로 의미없음
모바일에서 굉장히 편해짐.


초보는 div에 스크롤y를 건다.
ios 10에서도 겁나느림.
어쨌든 overflow y는 스크롤로 해결할 수 없다.

이때 fixed를 사용.

scroll top을 캐시로 잡고
현재 보는 레이어를 scroll top 0을 주고 fixed로 얼린다.

그 뒤에 div 위로 올라온 애가 body의 scroll top을 먹고
...

<caret position & offset>
보이진 않지만 캐럿 기반으로 오프셋을 얻어온다.

[OFFSET PARENT]()
OFFSET이란? 어떤 기준이 있는데 그 기준으로부터 얼마나 차이가 나는가. 기준이 없으면 오프셋이 없다.

왜 오프셋인가?
분할 정복, 사용자가 부분적으로 이해하기 편하도록. 완전 전체를 알 피료 없게 한다.

전체를 이해할 필요가 없음, 이건 그래픽에만 적용되는 이야기가 아님.
기준으로부터 얼마나 멀리 있는가를 의미하는 것.


HTML도 기본은 오프셋 시스템을 따르지만,
normal flow (BFC, IFC)를 따르지, 실제 앨리먼트가 그려지는건 돔 구조를 안따른다.

오프셋 역시 돔 구조를 따르지 않음. 영향은 받지만.


# 오프셋의 부모가 어떻게 정해지는가?
1. null인지 아닌지를 검사한다.
- root, html, body에게 오프셋을 얻으려고 하면 무조건 널.
- 나의 오프셋 페어런트? 없음.
- createElement했지만 아직 append되지 않았다? 오프셋이 널.

2. 위에 케이스가 아니다? 돔 트리를 찾아서 결정된다. (recursive)
- 내 부모가 fixed가 나왔는가? 그럼 없다.
- 부모 누군가가 static이 아니다? 그럼 그게 나의 기준이 된다.
- 위에도 없다? 바디가 오프셋.
- TD, TH, TABLE이 내 부모 중에 있다? 오프셋 페이런트가 된다. display table cell type으로 정해놨다고 해도 안됨. 태그를 통해서 오프셋을 얻을 수 있는 부모가 된다.
- 위에 과정이 계속 반복됨.

오프셋은..
offsetLeft, Top, Width, Height

-- 스크롤 없이 내가 가져야할 높이 너비가 스크롤width, height
offsetScrollTop, Left, Width, Height



normal flow(BFC, IFC)를 타고 나면, css가 전부 다 박아줌. css랜더링엔진이 지오매트리 계산할때 전부 계산해서 갖다 박아줌. 읽기 전용이고, 바꿔봤자 쓸모 없다. css 엔진이 그려낸 레포트일뿐.
자신의 지오매트리가 페어런트로부터 어떻게 되어있는지.

%로 그리라고 명령한 이후 실제로 그려진 결과를 얻고싶다? offset value를 통해 그 리포트를 그려낸다.

reflow -> repaint 초당 60frame씩 하려고 한다.
브라우저에서 초당 60 grame? 한번 그릴때 그렇게 안하고 다 모아서 함.
페레임 단위로.


!!!자바스크립트 프레임!!!당, 묶어서 전부 reflow.
element 1번 50너비
2번 20
3번은 a,b 오프셋 위쓰는?

오프셋을 쓰면 무조건 리플로우 한다.
offset은 최대한 안부르는게 좋다. 부르면 여태 쌓여있던 버퍼내 값을 전부 다 가져온다.
사후 값!!




left, top은 기본값. prestine한 값이다. 건드는 순간 없어짐. 아무것도 손 대면 기본값이 아님.

포함하는 앨리먼트의 경계값!이 기준?

<<<<기본값 left top은 자기를 포함하고 있는 경계면을 의미한다.>>>>
absolute계의 애들은 left-right를 각각0으로 줘서 부모로부터 너비를 다 먹게.

근데 left를 주면? 자신의 parent 오프셋으로부터 계산해서 붙는다.


offset기반이 되어야지만 z-index를 먹는다.
노멀플로우(bfc, ifc)에 속한 애들에게는 z-index먹여봐야 안먹음.




자식 포함관계에서의 z-index는?



relative가 absolute bridge역할을 한다.
이 relative를 통해서 absolute계의 놈들을 normal flow로 삽입시킬 수 있다.

보더 두께가 변경될떄 스크롤이 생기는 버그가 좀 있음.
