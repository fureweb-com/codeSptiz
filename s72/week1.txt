<!-- 출석 경로 -->
<!-- http://oxizen.net/projectBS/s72/attend.php?r=1&c=1&p=8763 -->


<!-- CSS RENDERING - Graphics system & normal flow -->
<!-- CSS는 5세대 언어, 표현언어 - 선언만 하면 작동되게 한다. (백그라운드를 칠해줘) / canvas는 그렇지 않음. 다 한땀한땀. -->
<!-- 선언형 언어는 많은 부분이 자동화된 언어. -->
<!--
bitmap -> pixelmap.. 엄밀한 의미의 비트맵은 흑백만 표기될것이다.
4byte방식(32bit) - true color
rgba까지 우리가 쓰는 true color 체계.

컬러 표현 방식은 굉장히 여러가지가 있음. 녹색에 민감한 인간 눈에 맞춰 그쪽만 섬세하게 하고 나머지 감도를 떨군다.

==============================
X, Y, Width, height, color -> 지정해줘야하는 것 -> 확정된 값이 필요한 체계 : Fixed number 체계
==============================

사이즈의 실체
screen size
chrome size
hierarchy

기준으로부터 정해져야하는 사이즈 체계

계산방식을 추상화시킨 단위를 사용한다.
위와 같은 단위를 쓸 수 있는 것 - 기준이 있어야 한다.
=================================
%, left, right, inline, float -> Abstract calculator 체계
=================================
고정 값이 아닌, 상대적 단위를 사용.


=================================
Components 체계 - 화면을 컴포넌트를 통해 구현한다.
=================================

=================================
일관성 있는 컴포넌트들의 집합 => Framework 체계
=================================



graphics system과 rendering system은 다른 개념

graphics system은 원래 그림으로 존재했다.
그림이 아닌 것을 가지고 그림을 표현한다 -> 렌더링.

geometry calculate ==== reflow
- 각각 앨리먼트가 브라우저 내에서 가져야할 영역에 대해 계산한다.

fragment fill ==== repaint
- 지오매트리 위에 선언된 대로 색칠. pixel은 하나의 점을 의미하는데, 좀 더 넓은 의미로서의 fragment라는 단어 차용.

모든 렌더링 엔진들은 위 과정을 거친다.


픽셀마다 무슨 짓을 해야하는 것은 fragment fill 과정이 가장 부하가 심하다.
영역만 구하고, 칠할때는 반복.


지오매트리를 다시 계산하는건 비용이 엄청나다. repaint만 다시 하는건 값싸다. for loop에 대한 비용은 쎄지만, 지오매트리가 변함으로써 생기는 repaint 비용들은 어마어마하다.

지오매트리에 관여하는 속성 너비, 높이, 포지션

fragment는 백그라운드, 컬러 등등...



css에서는 지오매트리 속성을 구하는게 더 어렵다. 색칠은 국소적 문제이므로 이해가 편하다.

=========================


CSS 스펙

CSS의 본질? 약속이다.
어떤 코드를 어떻게 계산해달라. 약속이 전부.
서로 얼마나 동의했느냐가 문제.
과거 W3C -> HTML5 재단에서 같이 관리.
CSS최신 스펙은 계속 초안 -> 확정 과정 거침.


CSS 1.0 (LEVEL 1)
A4 용지 한장 정도의 스펙. 이 당시에는 브라우저밴더들이 주도하지 않음. level 1에서 width height같은 것들이 많이 들어가니, 

CSS 2.0 (level 2)
CSS 1 사양서와 CSS 2 사양서가 있던 이때의 시기.
표현과 내용을 분리하자는 의미로 CSS2를 쓰기 시작함.
이때부터 브라우저의 커스텀스펙들이 엄청 전용 스펙들이 중구난방으로 늘어남.
그래서 CSS Level 2 + Module 
모듈화 시켜버리자는 형태로 감.

CSS를 모듈로 쪼개서... 이후 버전의 등장


CSS 2.1(level 2.1)
(include level 3 module)
이제부터 모듈 스펙서가 등장하기 시작한다.
syntax 3, values3, cascade 3.....
이미 각각의 많은 모듈들이 버전3가 되었다.


CSS의 스펙은 더이상 없고, 각각 쪼개진 모듈별로 버저닝이 되기 시작했다.
CSS는 레벨로 더이상 부르지 않고, Module level로 부르기 시작한다. 사실 css3는 없는 것.

flexbox, grid, effects, compostiion transforms1, masking 1.... 이런 애들.
현재 이 모듈들 거의 태반은 draft 상태.
css3는 존재하지 않는다. 2.1에서 level 3~이상의 놈들이 존재하는 것.

이제 css 모듈별로 버전을 따로 불러야한다.

모든 css 기능별, 모듈별로 그냥 각자 생존하게 됨.


전 세계에서 css 스펙을 모두 이해하는 사람은 없다.


=======
정확한 용어로 정확하게 설명해야한다.
=======















NORMAL FLOW
CSS1.0 2.0 2.1의 핵심 알고리즘
이걸 이해하지 못하면 기존 css(기존 그래픽 원리)를 그리는 방법을 모른다는 것.

==>Visual Formatting model -> 포지셔닝 스킴스 * 노멀 플로우

포지션은.. css 2.1 스펙 기준
static (기본값) ===> nomal flow 영향
relative ===> nomal flow 영향
- 이하는 영향 받지 않음.
absolute
fixed
inherit



노멀 플로우 알고리즘 원리는
BFC / IFC / RP (relative positioning)
위 3가지에 영향을 받는다.

BFC -> 하위 앨리먼트들의 offset의 기준이 된다. offset을 이곳으로 부터 얻어와서 위치를 지정시킨다.
IFC 역시, offset을 얻을 수 있게 해주는 context. 컨텍스트 내부에 배치될 inline element들의 공간 위치를 배정할 수 있도록 값들이 저장되어있다.

BFC를 완전히 새로 만들 수 있도록 하는 키워드들이 별도로 정해져있다.



BFC / IFC / RP등으로 지오매트리 캘큘레이트를 마친 뒤 repaint를 처리한다.


div overflow auto

기본 overflow가 auto기에 내부 



텍스트 노드에 대한 별도 규정. 캐리지리턴 라인피드, 개행문자 등을 텍스트 노드에서 사용하면, IFC 입장에서는 3개의 span으로 보이게 된다.
경계면이 되면 다음줄로 내리는 알고리즘이 있어서. 더 어렵다.


word-break는 안에 들어있는 ifc 요소들에 대해 한글자 한글자에 대해 문자들을 내려줄 수 있도록 하기 위한 속성이다.


노멀플로우는 BFC/IFC/RP를 통한 랜더링은 의미한다.







POSITIOn relative의 의미-
인라인 앨리먼트에 이것을 걸어준다면.
노멀 플로우를 타고 가다가, 그 기준에 대해 relative-top:50px 주면, 원래까지 정상적으로 그려지던 위치로부터 50px top위치를 가진 상태로 해당 앨리먼트를 그린다.











===================================
FLOAT
===================================
LEFT | RIGHT | NONE | INHERIT

모듈별로 스펙이 참 더럽게 되어있다. css를 리셋해서 없애는 속성은..속성별로 다 다르다. none이나 unset null 등등..이상한게 많음.

float를 선언하면, 새로운 BFC 계산식을 시작시킨다.
float 는 새로운 bfc를 생성하고, 그것을 기준으로 둥둥 떠있다.
하지만 그 내부에 등장하는 ifc 내 앨리먼트들에는 영향을 끼친다.

float된 요소들은 ifc에 대해 가이드 역할을 한다.
플로트는 떠있으니까, 라인박스라는 원리?
float끼리는 line-box라는 것에 의해 그려진다.


float는 normal flow가 아닌, line box라는 시스템에 의해 그려진다.
IFC, BFC, RP랑 전혀 관계 없음.

float가 나오는 시점부터 새로은 BFC가 시작된다.
그 BFC위에서 떠 있고, float되지 않은 녀석이 바로 등장하면 바로 아래에 깔려서 나오게 된다.

FLOAT가 떠있는 BFC 영역 내에서는 INLINE이 그 float된 요소 안에 그려질 수 없다.

clear되기 전 까지는 가드 작동.

IFC에 대해서는 라인 가드로 작동한다.



LINE BOX 배치 방식을 알아야 FLOAT가 어떻게 배치되는지 알 수 있다.
BFC를 하나 만들고, FLOAT끼리는 선점하게되면 그 공간에 대해 남이 선점한 경우 자기가 쓸 수 있는 공간이 작아진다.

내가 들어갈 수 있는지 확인하고, 들어갈 수 없으면 다른 공간이 있는지 확인한다.



공간을 찾아보고
없으면 탑라인을 좀 더 밑으로 내린다
baseline에 자기 자신이 들어갈 수 있는 width가 될 때 까지 탐색을 시도한다.
있으면 float 방향에 따라 배치한다.

LINEBOX에서는 top line이 중요하다.

해당 baseline에 자기 자신의 width가 들어갈 수 있는지 확인해보고, 없으면 계속 topline을 밑으로 내린다.
온전한 사각의 공간. 어디 거치지 않게.
탑라인은 float가 만들어낸 BFC 영역 내에서 한번 내려가면 절대 그 baseline위 방향으로 올라가지 않게 된다.

LEFT는 LEFT가 먹어놨던 LEFT 공간이후에 그려져야하기때문에 7번의 박스가 좌측에 안가고 우측에가서 붙어있다.



=========================
LINE BOX + INLINE GUIDE ? GUARD ?
=========================

IFC가 라인을 내리긴 했지만 ,float때문에 밑으로 내려온다. block guard에 의해 내려옴.
block guard에 걸리면 자기가 속한 블록 엘리먼트를 visable로 overflow도 auto여서 높이를 늘릴것인데, float guard에 걸려서 밑으로 내려오면 자기가 들어갈곳..

IFC가 베이스라인을 내린다? 절대 뒤로 그 베이스라인을 높힐 수 없다.
베이스라인을 내린다는 것

float guard가 있으면 별도의 모듈이 적용된다.


============== 건의 : 페이지 번호가 장표에 있음 좋겠음 (우측상단)



LEFT가 이미 float left들로 인해 낮아진 baseline들을 계속 우측으로... 가면서 그와중에 가장 좌측을 취하는데, 없으면 내려간다.

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
========================
overflow
VISIBLE | HIDDEN | SCROLL | INHERIT | AUTO
========================


========================
overflow-x, -y
HTML 5 이후 모듈들에 들어있는 DRAFT상태...
VISIBLE | HIDDEN | SCROLL | CLIP | AUTO
========================
level 3 권고안
level 4 권고안...
overlow를 판단하는 기준이 모듈들에 따라 다 다름.
css 2.0시대에는 shadow box가 없었음. 그땐 없었으니까..

CSS 최대의 홀.. OVERFLOW, -X, -Y
명확한 기준을 전부 세울 수 없다 사실상.
<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>





========================
TEXT-OVERFLOW 무려 css2.1 시대의 표준.
CLIP | ELLIPSIS (말줄임표)
========================


그 외에 overlow들이 3개가 더 많다.




OVERFLOW는
VISIBLE이 아닐때에만 NEW BFC!
hidden, scroll을 사용하면 new bfc영역을 생성.
overflow: hidden을 막 쓰면 BFC가 졸라 많아져서 느려짐.



FIRST LINE BOX BOUND
-- 부모중의 블록 요소의 값을 가지지만, hidden으로 만들어지는 bfc는 - 아까 flot가 인라인박스를 구할 때, left피하고 right피할 때 처럼이 아니고,
BFC 초기값을 갖는 대신에  자기가 있어야 할 공간만 가진다.

아까 예제와 같은데, overflow hidden만 주면...
FLOAT로 BFC가 하나 생기는데, 그 내부에 자신이 그려질 가용한 공간 내에서 또 다른 BFC가 그려진다.

float요소의 공간을 찾아서, 그 내부 공간을 찾아서 그릴 수 있으면 그리고, 없으면 안그린다.

overflow:hidden은 자기자신이 들어갈 부모 BFC를 그려놓고, 그 안에 자기 자신이 들어갈 공간이 있을 때에만 새로운 BFC공간을 float 내에 남아있는 공간을 찾아보고, 없으면 안그리고 그냥 랜더링이 포기된다.

LEFT float가 전부 다 공간을 차지해버렸다면, 자기 자신이 그려질 곳이 없어져버린다. left로 인해 우측으로 끝까지 간 경우, baseline이 해당 위치에 갔지만 float:left 공간이 이미다 꽉 차있다면?



노멀 플로우는 포지션 static일때.
BFC IFC RP
기본적인 노멀플로우에서 벗어나게 해주는 것이
FLOAT와 OVERFLOW(not visible)

인라인 가드로 작동하기때문에 그 부분을 잘 알아야함.
overflow가 visible이 아닌 것들의 지오매트리를 계산할 때



 
























-->